# 항해99_알고리즘_2021-03-11, 백준번호: 11053_가장 긴 증가 수열../by 정석진

# 가장 긴 증가수열은 특정 배열에서 숫자들을 조합해 오름차순으로 정렬 할수 있는 최대 길이를 말한다.
# 문제 예시에서 수열 {10, 20, 10, 30, 20, 50}에서의 오름차순 정렬을 해보면
# {10}, {10, 20}, {10,20,30}, {10,20,30,50} 간소하게 보면 이정도 인데
# 다른 인덱스의 숫자로 조합해도 {10,20,30,50}이것보다 긴것은 나올수 없다.
# 해서 최장길이는 4

r = int(input())  # 우선 문제요구대로 배열의 크기를 입력한다.
a = list(map(int, input().split()))  # 배열을 만들고 역시 값을 넣어준다.

# 먼저 배열과 같은 크기를 같는 1로 가득찬 배열을 하나 만들어준다. ex) r=6, res={1,1,1,1,1,1}
res = [1 for i in range(r)]

# 배열의 길이만큼의 반복문
for i in range(r):
    # 해당 로직은 오름차순 정렬에 대해 생각해야 수월하다 오름차순 정렬을 하려면
    # 자신보다 왼쪽에 있는 숫자가 자신보다 작아야 오름차순 정렬이다. ex) 2를 기준으로 1,2 => 오름차순O / 2,2 => 오름차순x
    # 2번째 자리보다 작은 숫자가 있어야하는것은 1번째 자리이다. ex) 3번째 자리면 우리는 1부터 3까지의 자리만 비교해주면 된다.
    for j in range(i):
        if a[i] > a[j]:  # ex)i=3 j=0~2  a[3] > a[0~2] => 30 > 10,20,10

            # 하나씩 비교해서 큰게 맞으면 res[i]와 res[j] + 1 중에 큰값을 res[i] 담아준다
            # 이 숫자는 해당 인덱스 번호의 숫자가 가질수 있는 오름차순 정렬 배열 길이 이다 모든 숫자는 자기자신의 오름차순 정렬을 가질수 있기때문에 res={1,1,1,1,1,1}를 해준것!
            # 이말은 숫자를 누적해주기 위함과 바로 왼쪽의 숫자가 자신보다 작은데 가지고 있는 오름차순 정렬 길이가 3이라면 그것보다 큰수인 자신은 당연히 +1개
            res[i] = max(res[i], res[j] + 1)

print(max(res))  # 그중 제일 큰것 = 제일 긴 오름차순 길이
