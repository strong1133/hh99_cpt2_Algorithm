# 항해99_알고리즘_2021-03-10, 백준번호: 1003_피보나치수열../by 정석진


# 피보나치 수열은 0,1,2,3,5,8,13,21 ... 이런식으로 n에 위치에 이전 숫자들을 더해서 구해진다는 규칙을 가잔다
# 이를 공식화 화면  => n-1번째와 n-2번째를 더해서 n을 구한다는 공식이 나온다.

t = int(input())  # 먼저 케이스 갯수를 입력 받는다

while t:  # 케이스 갯수가 0이 될때 까지
    z = [1, 0]
    o = [0, 1]  # 한발느린 피보나치와 일반 피보나치를 만들기 위한 포석 아래 설명을 보고 다시보면 이해가능.
    n = int(input())  # 각 케이스의 숫자를 넣는다

    for i in range(2, n+1):  # 피보나치 수열의 공식은 숫자 2부터 1+2 형식으로 적용 되기 때문에 2부터 꺼내온다
        # ex) n=3 이면 i = 2,3,4 (n+1)까지기 때문  i=2로 내려가보자
        # z[1] + z[0]  = 0 + 1  => i=3_ z[2] + z[1] => 1+0 =1
        # o[1] + o[0]  = 1 + 0  => i=3_ o[2] + o[1] => 1+1 =2
        # 이 소스는 append라서 i가 2일대 구해진 값이 z의 마지막에 삽입된다. 따라서 z[2]는 1
        # i=4_ z[3] + z[2] => 1+1 =2
        # i=4_ o[3] + o[2] => 2+1 =3 #i가 4라서 반복문 종료
        # z = [1,0,  1, 1, 2]  => 진행 방식역시 피보나치 수열
        # o = [0,1,  1, 2, 3]  => 결과적으로 구하려던 3이 구해진 시점에 반복문도 종료되었음
        # z와 o는 z가 o에 비해 한발 늦는 피보나치임을 알수 있다.
        # case가 구해지기 직전 즉 케이스와 동일한 숫자를 갖는 인덱스에서 case가 3일때 목표값은 4번 인덱스에 저정되었다.
        # 3번 인덱스를 보면 각 1과 2
        # 이는 3을 구하기위해 사용된 0의 갯수와 1의 갯수와 같다.
        # 한발늦는 피보나치 z는 0의 갯수를 피보나치 o는 1의 갯수를 나타내준다.
        z.append(z[i-1] + z[i-2])
        o.append(o[i-1] + o[i-2])

    t -= 1
    # 한개의 케이스가 끝났으니 전체 케이스 수에서 -1 while 탈출 조건을 위함

    print(z[n], o[n])  # 케이스와 동일한 숫자의 인덱스는 해당 케이스 숫자를 구하기 위해 더해진 값이 저장되어 있음
